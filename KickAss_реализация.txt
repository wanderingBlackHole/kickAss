/*
 * Файл: gapbuf.cpp
 * ------------------
 * Этот файл реализует класс EditorBuffer, используя
 * Gap Buffer для представления буфера.
 */

Одним из выходов, улучшающих характеристики буфера текстового редактора
может быть использование Gap Buffer.

В такой реализации мы храним посередине текста пустой буфер для быстрого
впечатывания\удаления чего-нибудь. В начале этого пустого блока размещаем
редактируемый текст до курсора, в конце - текст после курсора. Текст хранится 
в памяти двумя непрерывными кусками, а в промежутке между ними находится 
вся доступная для текста свободная память.

Нам надо иметь позиции начала и конца буфера.

/* private-Поля */

    char[] m_array;
    int m_gapStart;
    int m_gapEnd;


EditorBuffer::EditorBuffer() 
{
    m_array = new char[SIZE];
    m_gapStart = 0;
    m_gapEnd = SIZE;
}

EditorBuffer::~EditorBuffer() 
{
    delete[] m_array;
}

Перемещение курсора вызывает копирование текста с одной стороны окна в другую

void EditorBuffer::moveCursorForward() {
// бла бла
}
void EditorBuffer::moveCursorBackward() {
// бла бла
}
void EditorBuffer::moveCursorToStart() {
// бла бла
}
void EditorBuffer::moveCursorToEnd() {
// бла бла
}

void EditorBuffer::insertCharacter(char ch) {

// Подвинуть Gap Buffer на место вставки
// Скопировать ch в начало Gap Buffer
// При необходимости переаллоцировать Gap Buffer

}
void EditorBuffer::deleteCharacter() {

// Передвинуть Gap Buffer на место удаления
// Удалить символ после курсора
// Размер Gap Buffer будет увеличен на один символ

}

void EditorBuffer::display() {
// Аналогичен всем дисплеям
}

Добавляем методы перемещения курсора на 1 строку вверх и вниз
/* private-Поля */
int m_stringLength; // инициализируется в конструкторе константой

void EditorBuffer::moveCursorUp() {

    // Перемещаем Gap Buffer на m_stringLength вперед
    // минус расстояние от начала строки если надо в начало строки
}

void EditorBuffer::moveCursorDown() {

    // Перемещаем Gap Buffer на m_stringLength назад
    // минус расстояние от начала строки если надо в начало строки
}

Оптимизация параметров реализации с использованием ограничений на редактируемый текст

* Количество символов в строке буфера не больше ширины экрана.
* Рамер текста - не бесконечный.

~~~~~~ Оценки ~~~~~~

Операции вставки и удаления — дешевые: O(1) как при вставке отдельного символа, 
так и их группы.

Накладные расходы по памяти — низкие. Нужно хранить только положение курсора 
и общий размер буфера.

Расходы на перемещение курсора - есть, так как приходится копировать текст из нижнего 
заполненного участка буфера в верхний или наоборот. Сложность перемещения курсора — O(n), 
где n — расстояние, на которое перемещается курсор. При перемещениях из начала в конец 
текста может проявиться ощутимая пользователем задержка. Однако перемещения из начала в конец 
текста — относительно редкая операция при его редактировании. Чаще встречаются перемещения на 
символ или строку вперед или назад, и тогда приходится перемещать лишь небольшой участок текста.
